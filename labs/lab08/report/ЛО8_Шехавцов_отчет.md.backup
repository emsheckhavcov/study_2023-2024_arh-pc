# Отчёт по лабораторной работе №8
## Дисциплина: архитектура компьютеров и операционные системы
### Шехавцов Евгений Михайлович
### Содержание
1	Цель работы	1
2	Задание	1
3	Теоретическое введение	1
4	Выполнение лабораторной работы	2
4.1	Реализация циклов в NASM	2
4.2	Обработка аргументов командной строки	5
4.3	Задание для самостоятельной работы	8
5	Выводы	10
6	Список литературы	10

## 1	Цель работы
Приобретение навыков написания программ с использованием циклов и обработкой аргументов командной строки.
## 2	Задание
   1. Реализация циклов в NASM.
   2. Обработка аргументов командной строки.
   3. Задание для самостоятельной работы.
## 3	Теоретическое введение
Стек — это структура данных, организованная по принципу LIFO («Last In — First Out» или «последним пришёл — первым ушёл»). Стек является частью архитектуры процессора и реализован на аппаратном уровне. Для работы со стеком в процессоре есть специальные регистры (ss, bp, sp) и команды. Основной функцией стека является функция сохранения адресов возврата и передачи аргументов при вызове процедур. Кроме того, в нём выделяется память для локальных переменных и могут временно храниться значения регистров. Стек имеет вершину, адрес последнего добавленного элемента, который хранится в регистре esp (указатель стека). Противоположный конец стека называется дном. Значение, помещённое в стек последним, извлекается первым. При помещении значения в стек указатель стека уменьшается, а при извлечении — увеличивается.
Команда push размещает значение в стеке, т.е. помещает значение в ячейку памяти, на которую указывает регистр esp, после этого значение регистра esp увеличивается на 4. Данная команда имеет один операнд — значение, которое необходимо поместить в стек.
Команда pop извлекает значение из стека, т.е. извлекает значение из ячейки памяти, на которую указывает регистр esp, после этого уменьшает значение регистра esp на 4. У этой команды также один операнд, который может быть регистром или переменной в памяти. Нужно помнить, что извлечённый из стека элемент не стирается из памяти и остаётся как “мусор”, который будет перезаписан при записи нового значения в стек.
Для организации циклов существуют специальные инструкции. Для всех инструкций максимальное количество проходов задаётся в регистре ecx. Наиболее простой является инструкция loop. Она позволяет организовать безусловный цикл.
## 4	Выполнение лабораторной работы
### 4.1	Реализация циклов в NASM
Создаю каталог для программ лабораторной работы № 8, перехожу в него и создаю файл lab8-1.asm. (рис.1).
![Создание файлов для лабораторной работы](image/Screenshot_1.png)
Ввожу в файл lab8-1.asm текст программы из листинга 8.1. (рис.2).
![Ввод текста из листинга 8.1](image/Screenshot_2.png)
Создаю исполняемый файл и проверяю его работу. (рис.3).
![Запуск исполняемого файла](image/Screenshot_3.png)
Данная программа выводит числа от N до 1 включительно.
Изменяю текст программы, добавив изменение значения регистра ecx в цикле. (рис.4).
![Изменение текста программы](image/Screenshot_4.png)
Создаю исполняемый файл и проверяю его работу. (рис.5).
![Запуск обновленной программы](image/Screenshot_5.png)
В данном случае число проходов цикла не соответствует введенному с клавиатуры значению.
Вношу изменения в текст программы, добавив команды push и pop для сохранения значения счетчика цикла loop. (рис.6).
![Изменение текста программы](image/Screenshot_6.png)
Создаю исполняемый файл и проверяю его работу.(рис.7).
![Запуск исполняемого файла](image/Screenshot_7.png)
В данном случае число проходов цикла соответствует введенному с клавиатуры значению и выводит числа от N-1 до 0 включительно.
### 4.2	Обработка аргументов командной строки
Создаю файл lab8-2.asm в каталоге ~/work/arch-pc/lab08 и ввожу в него текст программы из листинга 8.2. (рис.8).
![Ввод текста программы из листинга 8.2](image/Screenshot_8.png)
Создаю исполняемый файл и запускаю его, указав нужные аргументы. (рис.9).
![Запуск исполняемого файла](image/Screenshot_9.png)
Программа вывела 4 аргумента, так как аргумент 2 не взят в кавычки, в отличии от аргумента 3, поэтому из-за пробела программа считывает “2” как отдельный аргумент.
Рассмотрим пример программы, которая выводит сумму чисел, которые передаются в программу как аргументы. Создаю файл lab8-3.asm в каталоге ~/work/archpc/lab08 и ввожу в него текст программы из листинга 8.3. (рис.10).
![Ввод текста программы из листинга 8.3](image/Screenshot_10.png)
Создаю исполняемый файл и запускаю его, указав аргументы. (рис.11).
![Запуск исполняемого файла](image/Screenshot_11.png)
Изменяю текст программы из листинга 8.3 для вычисления произведения аргументов командной строки. (рис.12).
![Изменение текста программы](image/Screenshot_13.png)
Создаю исполняемый файл и запускаю его, указав аргументы. (рис.13).
![Запуск исполняемого файла](image/Screenshot_14.png)
### 4.3	Задание для самостоятельной работы
Написал программу, которая находит сумму значений функции f(x) = 15x + 2 (Вариант 11) для x = x1, x2, …, xn. Создал исполняемый файл и проверил его работу на нескольких наборах x = x1, x2, …, xn.(рис.14).
![Текст программы](image/Screenshot_15.png)
Создаю исполняемый файл и проверяю его работу на нескольких наборах x = x1, x2, …, xn. (рис.15).
![Запуск исполняемого файла и проверка его работы](image/Screenshot_16.png)
Программа работает корректно.
Код программы:
%include 'in_out.asm'
SECTION .data
   msg db "Результат: ",0
SECTION .text
   global _start
_start:
   pop ecx    ; Извлекаем из стека в `ecx` количество
              ; аргументов (первое значение в стеке)
   pop edx    ; Извлекаем из стека в `edx` имя программы
              ; (второе значение в стеке)
   sub ecx,1  ; Уменьшаем `ecx` на 1 (количество
              ; аргументов без названия программы)
   mov esi, 0 ; Используем `esi` для хранения
              ; промежуточных сумм
next:
   cmp ecx,0h ; проверяем, есть ли еще аргументы
   jz _end    ; если аргументов нет выходим из цикла
              ; (переход на метку `_end`)
   pop eax    ; иначе извлекаем следующий аргумент из стека
   call atoi  ; преобразуем символ в число
   
   imul eax, 15    ; умножаем x на 15
   add eax, 2      ; добавляем 2 
   add esi,eax     ; добавляем значение функции для 
                   ; конкретного аргумента к промежуточной сумме
   loop next       ; переход к обработке следующего аргумента
_end:
   mov eax,msg    ; вывод сообщения "Результат: "
   call sprint
   mov eax,esi    ; записываем сумму в регистр `eax`
   call iprintLF  ; печать результата
   call quit      ; завершение программы
## 5	Выводы
Благодаря данной лабораторной работе я приобрел навыки написания программ использованием циклов и обработкой аргументов командной строки, что поможет мне при выполнении последующих лабораторных работ.
## 